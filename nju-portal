#!/usr/bin/env python3

import getpass
import time

import argparse
import json
import requests
from utility import logging


class Portal:
  def __init__(self, *args, command, username, password, request_interval, loop, loop_interval, force, level, **kwargs):
    self.origin = "http://p.nju.edu.cn/portal_io"
    self.headers = {}
    self.timeout = (3.1, 15.1)

    self.username = username or input("username: ").lower()
    self.password = password or getpass.getpass("password: ")
    self.username_last = None

    self.request_time_last = 0.0
    self.request_interval = request_interval

    loop_time_last = 0.0

    self.level = level

    if command == "info":
      while True:
        loop_time_last = self.sleep_until(loop_time_last + loop_interval)
        self.getUsername()

        if not loop:
          break
    elif command == "logout":
      while True:
        loop_time_last = self.sleep_until(loop_time_last + loop_interval)
        self.logout()

        if not loop:
          break
    elif command == "login":
      while True:
        loop_time_last = self.sleep_until(loop_time_last + loop_interval)
        username = self.getUsername()
        if username is None:
          self.login()
        elif force and username != self.username:
          self.logout()
          self.login()

        if not loop:
          break

  def login(self):
    logininfo = self.post("login", data={"username": username, "password": password})
    logging.info("login: {}".format(logininfo))
    # {'reply_code': 3, 'reply_msg': 'E011 您的账户余额不足!', 'request_uri': '/portal_io/login', 'request_time': 1551685692}
    # {'reply_code': 6, 'reply_msg': '已登陆!', 'userinfo': {'username':'', 'fullname': ''}, 'request_uri': '/portal_io/login', 'request_time': 1551686244}
    # if ret["reply_code"] == 3: # 余额不足
    return ret

  def logout(self):
    logoutinfo = {}
    logging.info("logout: {}".format(logoutinfo))

  def getUsername(self):
    ret = {"username": None}
    userinfo = self.post("getinfo")
    if "userinfo" in userinfo and "username" in userinfo["userinfo"]:
      userinfo = userinfo["userinfo"]
      volume = self.post("selfservice/volume/getlist")
      if "rows" in volume and isinstance(volume["rows"], list) and len(volume["rows"]) > 0:
        volume = volume["rows"][0]
        ret = {
          "username": userinfo["username"],
          "fullname": userinfo["fullname"],
          "client_ip": ".".join([str(userinfo["useripv4"] // (256**i) % 256) for i in range(3, -1, -1)]),
          "balance": "RMB {}.{}".format(userinfo["balance"] // 100, userinfo["balance"] % 100),
          "use_time": ":".join([str(volume["total_ipv4_volume"] // (60**i) % (744 if i == 2 else 60)) for i in range(2, -1, -1)]) + " h"
        }

    username = ret["username"]
    if self.username_last != username:
      logging.info("info: {}".format(ret))
      self.username_last = username

      if self.level >= logging.CRITICAL:
        print(username)

    return username


  def post(self, pathname, data=None):
    try:
      with requests.Session() as s:
        s.headers.update(self.headers)

        self.request_time_last = self.sleep_until(self.request_time_last + self.request_interval)
        r = s.post(f"{self.origin}/{pathname}", data=data, timeout=self.timeout)
    except requests.Timeout as e:
      logging.warning(f"catch exception: {e}")
      r = None
    except Exception as e:
      logging.error(f"catch exception: {e}")
      r = None
    if r is None or r.status_code != 200:
      return {}
    return r.json()

  def sleep_until(self, next_time):
    while True:
      now = time.time()
      if next_time <= now:
        return now
      time.sleep(next_time - now)


def main():
  defaultLevel = logging.WARNING
  logging.addLevelNames()

  parser = argparse.ArgumentParser(description="Manage login/logout portal in Nanjing University.", epilog="Template epilog.")
  parser.add_argument("-V", "--version", action="version", version="%(prog)s 0.2")
  parser.add_argument("-q", "--quiet", help=f"set log level up to {', '.join([logging.getLevelName(level) for level in range(defaultLevel + 10, 60, 10)])} (default {logging.getLevelName(defaultLevel)})", action="count", default=0)
  parser.add_argument("-v", "--verbose", help=f"set log level down to {', '.join([logging.getLevelName(level) for level in range(defaultLevel - 10, 0, -10)])} (default {logging.getLevelName(defaultLevel)})", action="count", default=0)

  parser.add_argument("command", help="command for portal (%(choices)s)", choices=["login", "logout", "info"], metavar="COMMAND")
  parser.add_argument("-u", "--username", help="username of portal account")
  parser.add_argument("-p", "--password", help="password of portal account")
  parser.add_argument("--request-interval", help="interval between two requests", type=float, default=1.0)
  parser.add_argument("-l", "--loop", help="loop for command", action="store_true")
  parser.add_argument("--loop-interval", help="interval of loop", type=float, default=300.0)
  parser.add_argument("-f", "--force", help="login even if other user is login", action="store_true")

  args = parser.parse_args()
  args.level = min(max(0, defaultLevel + (args.quiet - args.verbose) * 10), logging.CRITICAL)

  logging.setLevel(args.level)
  logging.info(f"logging level is set to {logging.getLevelName(args.level)}")
  logging.info(f"Arguments: {args}")

  Portal(**args.__dict__)


if __name__ == "__main__":
  main()
